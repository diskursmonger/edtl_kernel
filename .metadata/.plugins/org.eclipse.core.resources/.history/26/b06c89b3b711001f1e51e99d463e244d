/*
 * generated by Xtext 2.34.0
 */
package su.nsk.iae.edtl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import su.nsk.iae.edtl.edtl.Model
import su.nsk.iae.edtl.edtl.Expression
import su.nsk.iae.edtl.edtl.Abbr
import su.nsk.iae.edtl.edtl.PrimaryExpression
import su.nsk.iae.edtl.edtl.XorExpression
import su.nsk.iae.edtl.edtl.AndExpression
import su.nsk.iae.edtl.edtl.UnExpression
import su.nsk.iae.edtl.edtl.Macros
import java.util.HashMap
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

import com.opencsv.CSVWriter
import java.io.StringWriter
import su.nsk.iae.edtl.edtl.impl.ExpressionImpl
import su.nsk.iae.edtl.edtl.impl.PrimaryExpressionImpl
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil.Copier
import java.util.Objects

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EdtlGenerator extends AbstractGenerator implements IEdtlGenerator {

//	static final String EXTENSION_ID = "su.nsk.iae.edtl.edtl_extension"
//	static final List<IEdtlGenerator> generators = new ArrayList
	
	val headerCsv = newArrayList(" ", "req name", "trigger", "invariant", "final", "delay", "reaction", "release", "LTL formula", "Substituted LTL formula")
	
	var String globalInterval = ""
	// + expanded LTL
	
	// Init expansion modules
	static def void initGenerators() {
//		val configuration = Platform.extensionRegistry.getConfigurationElementsFor(EXTENSION_ID)
//		for (el : configuration) {
//			val obj = el.createExecutableExtension("class")
//			if (obj instanceof IEdtlGenerator) {
//				generators.add(obj)
//			}
//		}
	}

	//	Substitute abbreviations and macroses
	override setModel(Model model) {
		model.reqs.stream.forEach([x | 
			x.trigExpr = x.trigExpr.treeReplacement
			x.invExpr = x.invExpr.treeReplacement
			x.finalExpr = x.finalExpr.treeReplacement
			x.delayExpr = x.delayExpr.treeReplacement
			x.reacExpr = x.reacExpr.treeReplacement
			x.relExpr = x.relExpr.treeReplacement
		])
	}
	
		// Get model and set model with abbrs and macroses
	override void beforeGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.
							toIterable.
							filter(Model).
							get(0)
		setModel(model)
	}
	
	// Call expansion modules
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('''«""»ltl_result.csv''', generateLtl())
		
		var csvStringWriter = new StringWriter()
		var csvWriter = new CSVWriter(csvStringWriter)
		
		csvWriter.writeNext(headerCsv)
		
		
		val ast = resource.allContents.
					toIterable.
					filter(Model).
					get(0)
		val reqs = ast.reqs
		
		globalInterval = ast.globInterval.globInterval.interval // format: 1h1m1s1ms
		System.out.println(globalInterval)
	
		var reqNum = 1
		
		for (req : reqs) {
			var trigger = convertExprToTermOrDefault(req.trigExpr, new BoolTerm(true))
			var invariant = convertExprToTermOrDefault(req.invExpr, new BoolTerm(true))
			var fin = convertExprToTermOrDefault(req.finalExpr, new BoolTerm(false))
			var delay = convertExprToTermOrDefault(req.delayExpr, new BoolTerm(false))
			var reaction = convertExprToTermOrDefault(req.reacExpr, new BoolTerm(true))
			var release = convertExprToTermOrDefault(req.relExpr, new BoolTerm(false))
			
			val x0 = con(trigger, no(release))
			val x1 = con(invariant, reaction)
			val x2 = dis(release, x1)
			val x3 = con(invariant, no(delay))
			val x4 = until(x3, x2)
			val x5 = con(fin, x4)
			val x6 = dis(release, x5)
			val x7 = con(invariant, no(fin))
			val x8 = until(x7, x6)
			val x9 = impl(x0, x8)
			val ltl_formula = globally(x9)

			var out = "\nRequirement " + req.name + ":\n" + 
			"trigger: " + convertExprToStringOrDefault(req.trigExpr, "true") + "\n" +
			"invariant: " + convertExprToStringOrDefault(req.invExpr, "true") + "\n" +
			"final: " + convertExprToStringOrDefault(req.finalExpr, "false") + "\n" +
			"delay: " + convertExprToStringOrDefault(req.delayExpr, "false") + "\n" +
			"reaction: " + convertExprToStringOrDefault(req.reacExpr, "true") + "\n" +
			"release: " + convertExprToStringOrDefault(req.relExpr, "false") + "\n\n" +
			"LTL formula:\n" + convertTermToString(ltl_formula, false) + "\n"
			// + expanded/substituted expr
			
			System.out.println(out)
			
			val csvRow = newArrayList(reqNum.toString(), req.name, 
				convertTermToString(trigger, false),
				convertTermToString(invariant, false),
				convertTermToString(fin, false),
				convertTermToString(delay, false),
				convertTermToString(reaction, false),
				convertTermToString(release, false),
				convertTermToString(ltl_formula, false),
				convertTermToString(ltl_formula, true)
				// + expanded LTL
			)
			
			csvWriter.writeNext(csvRow)
			reqNum++
		}
		
		csvWriter.close();
		
		var csv = csvStringWriter.toString()
		fsa.generateFile("ltl_output.csv", csv)
	}
	
	private def Term convertExprToTermOrDefault(Expression expr, Term defaultTerm) {
		return expr !== null ? convertExprToTerm(expr) : defaultTerm
	}
	
	private def Term convertExprToTerm(Expression expr) {
		if (expr === null) {
			throw new NullPointerException("Expression is null")
		}
		
		if (expr instanceof PrimaryExpression) {
			return convertPrimaryExprToPrimaryTerm(expr)
		}
		
		if (expr instanceof UnExpression) {
			return convertUnaryExprToUnaryTerm(expr)
		}
		
		if (expr instanceof AndExpression) {
			return new AndTerm(convertExprToTerm(expr.left), convertExprToTerm(expr.right))
		}
		
		if (expr.orOp !== null) {
			return new OrTerm(convertExprToTerm(expr.left), convertExprToTerm(expr.right))
		}
		
		throw new IllegalArgumentException("Unsupported expression type")
	}
	
	private def PrimaryTerm convertPrimaryExprToPrimaryTerm(PrimaryExpression expr) {
		if (expr === null) {
			throw new NullPointerException("Expression is null")
		}
		
		if ("FALSE".equals(expr.constant)) {
			return new BoolTerm(false)
		}
		
		if ("TRUE".equals(expr.constant)) {
			return new BoolTerm(true)
		}
		
		if (expr.tau !== null) {
			return new TimeTerm(String.valueOf(expr.tau.time.interval))
		}
		
		if (expr.v !== null) {
			return new VarTerm(expr.v.name)
		}
		
		if (expr.nestExpr !== null) {
			return new NestTerm(convertExprToTerm(expr.nestExpr))
		}
		
		throw new IllegalArgumentException("Unsupported primary expression type")
	}
	
	private def UnaryTerm convertUnaryExprToUnaryTerm(UnExpression expr) {
		if (expr === null) {
			throw new NullPointerException("Expression is null")
		}
		
		if (expr.unOp.equals("NOT") || expr.unOp.equals("!")) {
			return new NotTerm(convertPrimaryExprToPrimaryTerm(expr.right as PrimaryExpression))
		}
	
		if (expr.unOp.equals("FE")) {
			return new FeTerm(convertPrimaryExprToPrimaryTerm(expr.right as PrimaryExpression))
		}
		
		if (expr.unOp.equals("RE")) {
			return new ReTerm(convertPrimaryExprToPrimaryTerm(expr.right as PrimaryExpression))
		}
		
		if (expr.unOp.equals("HIGH")) {
			return new HighTerm(convertPrimaryExprToPrimaryTerm(expr.right as PrimaryExpression))
		}
		
		if (expr.unOp.equals("LOW")) {
			return new LowTerm(convertPrimaryExprToPrimaryTerm(expr.right as PrimaryExpression))
		}
		
		throw new IllegalArgumentException("Unsupported unary expression type")
	}
	
	private def String substituteTauCalcResult() {
		return ""
	}
	
	private def String calcTauResult() {
		
	}
	
	private def String convertTermToString(Term term, Boolean value) {		
		if (term instanceof AndTerm) {
			return "(" + convertTermToString(term.left, value) + " ∧ " + convertTermToString(term.right, value) + ")"
		}
		
		if (term instanceof OrTerm) {
			return "(" + convertTermToString(term.left, value) + " ∨ " + convertTermToString(term.right, value) + ")"
		}
		
		if (term instanceof ImplTerm) {
			return "(" + convertTermToString(term.left, value) + " → " + convertTermToString(term.right, value) + ")"
		}
		
		if (term instanceof WTerm) {
			return "W(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof FTerm) {
			return "F(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof GTerm) {
			return "G(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof UTerm) {
			return "(" + convertTermToString(term.left, value) + " U " + convertTermToString(term.right, value) + ")"
		}
		
		if (term instanceof BoolTerm) {
			return String.valueOf(term.value)
		}
		
		if (term instanceof VarTerm) {
			return term.name
		}
		
		if (term instanceof TimeTerm) {
			if (value == false){
				return "passed(" + String.valueOf(term.interval) + ")"
			} else {
				return "passed(" + String.valueOf(term.interval) + ")"
			}
		}
		
		if (term instanceof NestTerm) {
			return "(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof NotTerm) {
			return "¬" + convertTermToString(term.term, value)
		}
		
		if (term instanceof FeTerm) {
			return "FE(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof ReTerm) {
			return "RE(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof HighTerm) {
			return "HIGH(" + convertTermToString(term.term, value) + ")"
		}
		
		if (term instanceof LowTerm) {
			return "LOW(" + convertTermToString(term.term, value) + ")"
		}

		throw new IllegalArgumentException("Unsupported term type")
	}
	
	private def String convertExprToStringOrDefault(Expression expr, String defaultString) {
		return expr !== null ? convertExprToString(expr) : defaultString
	}
	
	private def String convertExprToString(Expression expr) {		
		if (expr instanceof PrimaryExpression) {
			if ("FALSE".equals(expr.constant)) {
				return "false"
			}
			
			if ("TRUE".equals(expr.constant)) {
				return "true"
			}
			
			if (expr.tau !== null) {
				return "passed(" + expr.tau.time.interval + ")"
			}
			
			if (expr.v !== null) {
				return expr.v.name
			}
			
			if (expr.nestExpr !== null) {
				return "(" + convertExprToString(expr.nestExpr) + ")"
			}
			
			throw new IllegalArgumentException("Unsupported primary expression type")
		}
		
		if (expr instanceof UnExpression) {
			if (expr.unOp.equals("NOT") || expr.unOp.equals("!")) {
				return "¬" + convertExprToString(expr.right)
			}
		
			if (expr.unOp.equals("FE")) {
				return "FE(" + convertExprToString(expr.right) + ")"
			}
			
			if (expr.unOp.equals("RE")) {
				return "RE(" + convertExprToString(expr.right) + ")"
			}
			
			if (expr.unOp.equals("HIGH")) {
				return "HIGH(" + convertExprToString(expr.right) + ")"
			}
			
			if (expr.unOp.equals("LOW")) {
				return "LOW(" + convertExprToString(expr.right) + ")"
			}
		}
		
		
		if (expr instanceof AndExpression) {
			return "(" + convertExprToString(expr.left) + " ∧ " + convertExprToString(expr.right) + ")"
		}
		
		if (expr.orOp !== null) {
			return "(" + convertExprToString(expr.left) + " ∨ " + convertExprToString(expr.right) + ")"
		}
		
		throw new IllegalArgumentException("Unexpected expression type")
	}
	
	private def Term con(Term l, Term r) {
		var left = l.copy
		var right = r.copy
		
		if (left instanceof BoolTerm) {
			if (left.value) {
				return right
			} else {
				return left
			}
		}
		
		if (right instanceof BoolTerm) {
			if (right.value) {
				return left
			} else {
				return right
			}
		}
		
		return new AndTerm(left, right)
	}
	
	private def Term dis(Term l, Term r) {
		var left = l.copy
		var right = r.copy
		
		if (left instanceof BoolTerm) {
			if (left.value) {
				return left
			} else {
				return right
			}
		}
		
		if (right instanceof BoolTerm) {
			if (right.value) {
				return right
			} else {
				return left
			}
		}
		
		// a ∨ a = a
		if (left.equals(right)) {
			return left
		}
		
		// a ∨ (b ∧ (a ∨ c)) = a ∨ (b ∧ c)
		if (right instanceof AndTerm) {
			var right_r = right.right
			if (right_r instanceof OrTerm) {
				if (right_r.left.equals(left)) {
					return new OrTerm(left, new AndTerm(right.left, right_r.right))
				}
			}
		}
		
		// a ∨ F(a ∨ b) = F(a ∨ b)
		if (right instanceof FTerm) {
			var right_t = right.term
			if (right_t instanceof OrTerm) {
				if (left.equals(right_t.left)) {
					return right
				}
			}
		}
		
		// a ∨ (b U a) = (b U a)
		if (right instanceof UTerm) {
			var right_r = right.right
			if (right_r.equals(left)) {
				return right
			}
		}
		
		// G(¬a) ∨ F(a) = true
		if (left instanceof GTerm) {
			var left_t = left.term
			if (left_t instanceof NotTerm) {
				if (right instanceof FTerm) {
					if (left_t.term.equals(right.term)) {
						return new BoolTerm(true)
					}
				}
			}
		}
		
		// a ∨ F(a) = F(a)
		if (right instanceof FTerm) {
			if (right.term.equals(left)) {
				return right
			}
		}
		
		// a ∨ (a ∨ b) = a V b | a ∨ (b ∨ a) = a ∨ b
		if (right instanceof OrTerm) {
			if (right.left.equals(left) || right.right.equals(left)) {
				return right
			}
		}
		
		// G(¬a) ∨ (F(a) ∨ (с)) = (с)
		if (left instanceof GTerm) {
			var left_t = left.term
			if (left_t instanceof NotTerm) {
				if (right instanceof OrTerm) {
					var right_l = right.left
					if (right_l instanceof FTerm) {
						if (left_t.term.equals(right_l.term)) {
							return right.right
						}
					}
				}
			}
		}
		
		// a ∨ (b U (a ∨ c)) = (b U (a ∨ c))
		if (right instanceof UTerm) {
			var right_r = right.right
			if (right_r instanceof OrTerm) {
				if (right_r.left.equals(left)) {
					return right
				}
			}
		}
		
		return new OrTerm(left, right)
	}
	
//	private def areLogicallyOpposite(Term l, Term r) {
//		var left = l.copy
//		var right = r.copy
//		
//		if (left instanceof BoolTerm) {
//			if (right instanceof BoolTerm) {
//				return left.value != right.value
//			}
//		}
//		
//		if (left instanceof NotTerm) {
//			if (!(right instanceof NotTerm)) {
//				return left.term.equals(right)
//			}
//		}
//		
//		if (!(left instanceof NotTerm)) {
//			if (right instanceof NotTerm) {
//				return right.expr.equals(left.expr)
//			}
//		}
//		
//		return false
//	}
	
	private def Term until(Term l, Term r) {
		var left = l.copy
		var right = r.copy
		
		if (right instanceof BoolTerm) {
			return right
		}
		
		if (left instanceof BoolTerm) {
			if (left.value) {
				return future(right)
			} else {
				return right
			}
		}
		
		// a U a = a
		if (left.equals(right)) {
			return left
		}
		
		// ¬a U a = F(a)
		if (left instanceof NotTerm) {
			if (left.term.equals(right)) {
				return future(right)
			}
		}
		
//		if (areLogicallyOpposite(left, right)) {
//			return future(right)
//		}
		
		// ¬a U (b ∨ a) = F(a) ∨ (¬a U b)
		if (left instanceof NotTerm) {
			if (right instanceof OrTerm) {
				if (left.term.equals(right.right)) {
					return dis(future(left.term), until(left, right.left))
				}
			}
		}
		
//		if (left instanceof NotTerm) {
//			if (right instanceof OrTerm) {
//				if (areLogicallyOpposite(left, right.right)) {
//					return dis(future(left.expr), until(left, right.left))
//				}
//			}
//		}
		
		// (a ∧ b) U (c ∨ a) = a ∨ ((a ∧ b) U c)
		if (left instanceof AndTerm) {
			if (right instanceof OrTerm) {
				if (left.left.equals(right.right)) {
					return dis(left.left, until(left, right.left))
				}
			}
		}
		
		// (a ∧ b) U a = a
		if (left instanceof AndTerm) {
			if (left.left.equals(right)) {
				return right
			}
		}
		
		// a U (b ∨ a) = a ∨ (a U b)
		if (right instanceof OrTerm) {
			if (left.equals(right.right)) {
				return dis(left, until(left, right.left))
			}
		}
		
		// (a ∧ ¬b) U (b ∧ a) = a U (b ∧ a)
		if (left instanceof AndTerm) {
			if (right instanceof AndTerm) {
				if (left.left.equals(right.right)) {
					var left_r = left.right
					if (left_r instanceof NotTerm) {
						if (left_r.term.equals(right.left)) {
							return until(left.left, right)
						}
					}
				}
			}
		}
		
//		if (left instanceof AndTerm) {
//			if (right instanceof AndTerm) {
//				if (left.left.equals(right.right)) {
//					if (areLogicallyOpposite(left.right, right.left)) {
//						return until(left.left, right)
//					}
//				}
//			}
//		}
		
		return new UTerm(left, right)
	}
	
	private def Term impl(Term l, Term r) {
		var left = l.copy
		var right = r.copy
		
		if (left instanceof BoolTerm || right instanceof BoolTerm) {
			return dis(no(left), right)
		}
		
		return new ImplTerm(left, right)
	}
	
	private def Term future(Term term) {
		var t = term.copy
		
		if (t instanceof BoolTerm) {
			return t
		} 
		
		return new FTerm(t)
	}
	
	private def Term no(Term term) {
		var t = term.copy
		if (t instanceof NotTerm) {
			return t.term
		}
		
		if (t instanceof BoolTerm) {
			t.value = !t.value
			return t
		}
		
		return new NotTerm(t)
	}
	
	private def Term globally(Term term) {
		var t = term.copy
		
		if (t instanceof BoolTerm) {
			return t
		}
		
//		// G(F(a)) = GF(a)
//		if (t instanceof FTerm) {
//			return new GTerm(t)
//		}
		
		// G(G(a)) = G(a)
		if (t instanceof GTerm) {
			return globally(t.term)
		}
		
//		if (t instanceof GTerm) {
//			return new GTerm(t.left)
//		}
		
		// G(G(a ∧ ¬b) ∨ (a U (b ∧ a))) = G(a)
		if (t instanceof OrTerm) {
			var t_left = t.left // G(a ∧ ¬b)
			if (t_left instanceof GTerm) {
				var t_right = t.right // (a U (b ∧ a))
				if (t_right instanceof UTerm) {
					var t_right_right = t_right.right // (b ∧ a)
					if (t_right_right instanceof AndTerm) {
						var t_left_term = t_left.term // (a ∧ ¬b)
						if (t_left_term instanceof AndTerm) {
							if (t_left_term.left.equals(t_right.left)) {
								if (t_right.left.equals(t_right_right.right)) {
									var t_left_term_right = t_left_term.right // ¬b
									if (t_left_term_right instanceof NotTerm) {
										if (t_left_term_right.term.equals(t_right_right.left)) {
											return globally(t_left_term.left) // G(a)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		
//		if (t instanceof OrTerm) {
//			if (t.left instanceof GTerm) {
//				if (t.right instanceof UTerm) {
//					if (t.right.right instanceof AndTerm) {
//						if (t.left.left instanceof AndTerm) {
//							if (t.left.left.left.left.equals(t.right.left)) {
//								if (t.right.left.equals(t.right.right.right)) {
//									if (areLogicallyOpposite(t.left.left.right, t.right.right.left)) {
//										return new GTerm(t.left.left.left)
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
		
		// G(G(a ∧ ¬b) ∨ ((a ∧ ¬b) U (b ∧ (a U (a ∧ c))))) = G(a ∧ (G(¬b) ∨ F(b ∧ F(c))))
		if (t instanceof OrTerm) {
			var t_left = t.left // G(a ∧ ¬b)
			if (t_left instanceof GTerm) {
				var t_right = t.right // ((a ∧ ¬b) U (b ∧ (a U (a ∧ c))))
				if (t_right instanceof UTerm) {
					if (t_left.term.equals(t_right.left)) {
						var t_right_right = t_right.right // (b ∧ (a U (a ∧ c)))
						if (t_right_right instanceof AndTerm) {
							var t_right_right_right = t_right_right.right // (a U (a ∧ c))
							if (t_right_right_right instanceof UTerm) {
								var t_right_right_right_right = t_right_right_right.right // (a ∧ c)
								if (t_right_right_right_right instanceof AndTerm) {
									var t_right_left = t_right.left // (a ∧ ¬b)
									if (t_right_left instanceof AndTerm) {
										if (t_right_left.left.equals(t_right_right_right.left)) { // a == a
											if (t_right_left.left.equals(t_right_right_right_right.left)) { // a == a
												var t_right_left_right = t_right_left.right // ¬b
												if (t_right_left_right instanceof NotTerm) {
													if (t_right_left_right.term.equals(t_right_right.left)) { // b == b
														return globally(con(
															t_right_left.left,
															dis(
																globally(t_right_left_right),
																future(con(
																	t_right_right.left,
																	future(t_right_right_right_right.right)	
																))
															)
														))
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		
		// G(G(a ∧ ¬b) ∨ ((a ∧ ¬b) U (b ∧ (a ∧ c)))) = G(a ∧ (G(¬b) ∨ F(b ∧ c)))
		if (t instanceof OrTerm) {
			var t_right = t.right // ((a ∧ ¬b) U (b ∧ (a ∧ c)))
			if (t_right instanceof UTerm) {
				var t_left = t.left // G(a ∧ ¬b)
				if (t_left instanceof GTerm) {
					var t_left_term = t_left.term // (a ∧ ¬b)
					if (t_left_term instanceof AndTerm) {
						var t_right_left = t_right.left // (a ∧ ¬b)
						if (t_right_left instanceof AndTerm) {
							if (t_left_term.equals(t_right_left)) {
								var t_right_right = t_right.right // (b ∧ (a ∧ c))
								if (t_right_right instanceof AndTerm) {
									var t_right_right_right = t_right_right.right // (a ∧ c)
									if (t_right_right_right instanceof AndTerm) {
										var t_right_left_right = t_right_left.right // ¬b
										if (t_right_left_right instanceof NotTerm) {
											if (t_right_left_right.term.equals(t_right_right.left)) { // b == b
												if (t_right_left.left.equals(t_right_right_right.left)) { // a == a
													return globally(con(
														t_right_left.left,
														dis(
															globally(t_right_left_right),
															future(con(t_right_right.left, t_right_right_right.right))
														)
													))
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		
//		if (t instanceof OrTerm) {
//			if (t.right instanceof UTerm) {
//				if (t.left instanceof GTerm) {
//					if (t.left.left instanceof AndTerm) {
//						if (t.right.left instanceof AndTerm) {
//							if (t.left.left.equals(t.right.left)) {
//								if (t.right.right instanceof AndTerm) {
//									if (t.right.right.right instanceof AndTerm) {
//										if (areLogicallyOpposite(t.left.left.right, t.right.right.left)) {
//											return globally(con(t.left.left.left, dis(globally(t.left.left.right), 
//												future(con(t.right.right.left, t.right.right.right.right)))))
//										}
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
		
		// G(G(a) ∨ (a U b)) = G(a ∧ F(b))
		if (t instanceof OrTerm) {
			var t_left = t.left // G(a)
			if (t_left instanceof GTerm) {
				var t_right = t.right // (a U b)
				if (t_right instanceof UTerm) {
					if (t_left.term.equals(t_right.left)) {
						return globally(con(t_left.term, future(t_right.right)))
					}
				}
			}
		}
		
		return new GTerm(t)
	}
	
/* ======================= TREE TRAVERSAL ======================= */
	def Expression treeReplacement(Expression expr){
		return expr.treeReplacement_Traversal()
	}
	
	def Expression treeReplacement_Traversal(Expression expr){
		if (expr === null){
			return expr
		}
		
		var e = expr
		e.left = expr.left.treeReplacement_Traversal()
		e.right = expr.right.treeReplacement_Traversal() as XorExpression
		
		if (expr instanceof PrimaryExpression) {
			val el = expr as PrimaryExpression
			if (el.v instanceof Abbr){
				val abbr = el.v
				val model = expr.getContainerOfType(Model)
				for (var i = 0; i < model.abbrs.size; i++){
					if (model.abbrs.get(i).name.equals(abbr.name)){
						return model.abbrs.get(i).expr.copy
					}
				}	
			} else	if (el.macros instanceof Macros){
				val macros = el.macros.copy as Macros
				val args = macros.args.copy
				var replace = new HashMap<String, Expression>
				var vars = el.args.copy
				for (var i = 0; i < args.vars.size; i++){
					if (vars.elements.get(i) instanceof Abbr){
						val abbr = vars.elements.get(i)
						val model = expr.getContainerOfType(Model)
						for (var j = 0; j < model.abbrs.size; j++){
							if (model.abbrs.get(j).name.equals(abbr.name)){
								replace.put(args.vars.get(i).name,
									model.abbrs.get(j).expr.copy
								)
							}
						}	
					} else {
						var prExpr = expr.copy
						prExpr.macros = null
						prExpr.args = null
						prExpr.v = vars.elements.get(i)
						replace.put(args.vars.get(i).name, prExpr)
					}
				}
				return macros.expr.treeReplacement_MacrosTraversal(replace)
			} else {
				return el
			}
		}
		return e
	}
	
	def Expression treeReplacement_MacrosTraversal(Expression expr, HashMap<String, Expression> replace){
		if (expr === null){
			return expr.copy
		}
		
		var e = expr.copy
		
		if (expr instanceof PrimaryExpression){
			var exp = replace.get(expr.v.name)
			if (exp !== null){
				return exp.copy
			} else {
				return expr.copy
			}
		}
		
		if (expr instanceof UnExpression){
			e.right = expr.right.treeReplacement_MacrosTraversal(replace) as XorExpression
			return e.copy
		}
		
		e.left = expr.left.treeReplacement_MacrosTraversal(replace)
		e.right = expr.right.treeReplacement_MacrosTraversal(replace) as XorExpression
		
		return e.copy
	}

	
}
/* ======================= END TREE TRAVERSAL ======================= */

interface Term {
	
	def Term copy()
	
}

class OrTerm implements Term {
	
	public Term left
	public Term right
	
	new (Term l, Term r) {
		this.left = l
		this.right = r
	}
	
	new (OrTerm term) {
		this.left = term.left !== null ? term.left.copy() : null
		this.right = term.right !== null ? term.right.copy() : null
	}
	
	override copy() {
		return new OrTerm(this)
	}

	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as OrTerm
	    
	    return Objects.equals(left, that.left)
	    	&& Objects.equals(right, that.right)
	}
	
	override hashCode() {
		return 1
	}

}

class AndTerm implements Term {
	
	public Term left
	public Term right
	
	new (Term l, Term r) {
		this.left = l
		this.right = r
	}
	
	new (AndTerm term) {
		this.left = term.left !== null ? term.left.copy() : null
		this.right = term.right !== null ? term.right.copy() : null
	}
	
	override copy() {
		return new AndTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as AndTerm
	    
	    return Objects.equals(left, that.left)
	    	&& Objects.equals(right, that.right)
	}

	override hashCode() {
		return 1
	}

}

class ImplTerm implements Term {
	public Term left
	public Term right
	
	new (Term l, Term r) {
		this.left = l
		this.right = r
	}
	
	new (ImplTerm term) {
		this.left = term.left !== null ? term.left.copy() : null
		this.right = term.right !== null ? term.right.copy() : null
	}
	
	override copy() {
		return new ImplTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as ImplTerm
	    
	    return Objects.equals(left, that.left)
	    	&& Objects.equals(right, that.right)
	}
	
	override hashCode() {
		return 1
	}
	
}

class WTerm implements Term {
	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (WTerm wTerm) {
		this.term = wTerm.term !== null ? wTerm.term.copy() : null
	}
	
	override WTerm copy() {
		return new WTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as WTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

class UTerm implements Term {
	public Term left
	public Term right
	
	new (Term l, Term r) {
		this.left = l
		this.right = r
	}
	
	new (UTerm term) {
		this.left = term.left !== null ? term.left.copy() : null
		this.right = term.right !== null ? term.right.copy() : null
	}
	
	override UTerm copy() {
		return new UTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as UTerm
	    
	    return Objects.equals(left, that.left)
	    	&& Objects.equals(right, that.right)
	}
	
	override hashCode() {
		return 1
	}
}


class GTerm implements Term {
	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (GTerm gTerm) {
		this.term = gTerm.term !== null ? gTerm.term.copy() : null
	}
	
	override GTerm copy() {
		return new GTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as GTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

class FTerm implements Term {
	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (FTerm fTerm) {
		this.term = fTerm.term !== null ? fTerm.term.copy() : null
	}
	
	override FTerm copy() {
		return new FTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as FTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

interface PrimaryTerm extends Term {
	
	override PrimaryTerm copy()
	
}

class BoolTerm implements PrimaryTerm {
	public boolean value
	
	new (boolean value) {
		this.value = value
	}
	
	new (BoolTerm term) {
		this.value = term.value
	}
	
	override BoolTerm copy() {
		return new BoolTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as BoolTerm
	    
	    return Objects.equals(value, that.value)
	}
	
	override hashCode() {
		return 1
	}
}

class VarTerm implements PrimaryTerm {
	public String name
	
	new (String name) {
		this.name = name
	}
	
	new (VarTerm term) {
		this.name = term.name
	}
	
	override VarTerm copy() {
		return new VarTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as VarTerm
	    
	    return Objects.equals(name, that.name)
	}
	
	override hashCode() {
		return 1
	}
}

class TimeTerm implements PrimaryTerm {
	public String interval
	
	new (String interval) {
		this.interval = interval
	}
	
	new (TimeTerm term) {
		this.interval = term.interval
	}
	
	override TimeTerm copy() {
		return new TimeTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as TimeTerm
	    
	    return Objects.equals(interval, that.interval)
	}
	
	override hashCode() {
		return 1
	}
}

class NestTerm implements PrimaryTerm {
	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (NestTerm nestTerm) {
		this.term = nestTerm.term !== null ? nestTerm.term.copy() : null
	}
	
	override NestTerm copy() {
		return new NestTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as NestTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

interface UnaryTerm extends Term {
	
	override UnaryTerm copy()
	
}

class NotTerm implements UnaryTerm {

	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (NotTerm notTerm) {
		this.term = notTerm.term !== null ? notTerm.term.copy() : null
	}
	
	override NotTerm copy() {
		return new NotTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as NotTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

class FeTerm implements UnaryTerm {

	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (FeTerm feTerm) {
		this.term = feTerm.term !== null ? feTerm.term.copy() : null
	}
	
	override FeTerm copy() {
		return new FeTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as FeTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

class ReTerm implements UnaryTerm {

	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (ReTerm reTerm) {
		this.term = reTerm.term !== null ? reTerm.term.copy() : null
	}
	
	override ReTerm copy() {
		return new ReTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as ReTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

class HighTerm implements UnaryTerm {

	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (HighTerm highTerm) {
		this.term = highTerm.term !== null ? highTerm.term.copy() : null
	}
	
	override HighTerm copy() {
		return new HighTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as HighTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}

class LowTerm implements UnaryTerm {

	public Term term
	
	new (Term term) {
		this.term = term
	}
	
	new (LowTerm lowTerm) {
		this.term = lowTerm.term !== null ? lowTerm.term.copy() : null
	}
	
	override LowTerm copy() {
		return new LowTerm(this)
	}
	
	override equals(Object o) {
	    if (this === o) return true
	    if (o === null || getClass() != o.getClass()) return false
	
	    var that = o as LowTerm
	    
	    return Objects.equals(term, that.term)
	}
	
	override hashCode() {
		return 1
	}
}